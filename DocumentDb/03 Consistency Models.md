It's very important to understand the consistency models in DocumentDB as it is one of the very few databases that provides us with a wide variety of those. A default consistency level can be configured on your database accounts. This applies to all collections across all of the databases. All reads and queries of the user-defined resources will by default, use the consistency level specified on the database account.


However, you can change the consistency level of a specific query by changing the header that's listed right here. It's x-ms-consistency-level. So, there are four different kinds of consistency levels supported by DocumentDB. The first one is strong consistency, something you see in an RDBMS. A read operation with strong consistency is higher than any of the others, but it's almost equal to the one in bounded staleness.

DocumentDB accounts using strong consistency cannot associate more than one Azure region with the DocumentDB account. In strong consistency, the structure guarantees the reads to return the most recent version of the document which is not the case with eventual consistency. For example, a write will only be visible once it is committed durably by the majority quorum of the replicas. It can either be synchronously committed by both the primary and the quorum of the secondaries.


It can also be aborted. A read is acknowledged by the majority read quorum. Bounded staleness. Bounded staleness can be configured in two ways. The first one is time interval and the second one is the number of versions of the document by which the reads lag behind the writes. The reads may lag behind the writes by at most k versions where k is any number or prefixes of a document or a time interval, t, which could be anything.

It could be five seconds, 30 seconds, one minute, whatever you want. With bounded staleness, the cost of a read operation which is measured in terms of request units which we'll discuss in a second will be higher than session and eventual consistency but will be the same as strong consistency. It also provides total global order outside the staleness window. The monotonic read guarantees exit within a region both inside and outside the staleness window.

Users can associate any number of Azure regions with their DocumentDB account, so that's an advantage over strong consistency. Because in case of strong consistency, you cannot really have multiple Azure regions. Session consistency. This is the most popular one out of the four. With session consistency, the cost of a read operation will be less than the strong and bounded staleness but more than eventual consistency. Any number of Azure regions can be associated with the account.

Monotonic reads, monotonic writes and read your own writes are guaranteed making it ideal for when a device or user session is involved. So for example, you are in a session as a user and you add a comment. So, you will be able to see your comment the moment you write that comment to DocumentDB. That may not mean that other users might be able to see it as it is, depending on what kind of consistency you are using. But since you are part of the same session, you will be able to see your own read.

Session consistency provides predictable consistency and the maximum throughput while also providing the lowest latency writes and reads. Eventual consistency. As it means, the eventual consistency level is the lowest of all consistency levels for the cost of a read operation. It is the weakest read consistency but provides the lowest latency for both reads and writes. Users can associate any number of Azure regions with their DocumentDB account.

It is the weakest form of consistency because the client may get values older than the ones it has previously seen. If no further writes are done, then the replicas within the group will eventually converge. Eventual consistency is a really good idea in terms of social networks. It is definitely not the consistency of choice when it comes to ecommerce apps.
